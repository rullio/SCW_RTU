/**
 ******************************************************************************
 * File Name          : cmds_system.c
 * Description        : This file is generated by 위대한 송 인재 on Aug 8, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

static void smb_cmd_clearScreen (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	(*pCmdIO->pCmdApi->msg)(cmdIoParam,  CUI_ESC_CLR);
	(*pCmdIO->pCmdApi->msg)(cmdIoParam,  CUI_ESC_CUR_HOME);
	return;
}

#if 0
typedef struct xTASK_STATUS
{
	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	UBaseType_t xTaskNumber;		/* A number unique to the task. */
	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
	configSTACK_DEPTH_TYPE usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
} TaskStatus_t;

/* Task states returned by eTaskGetState. */
typedef enum
{
	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
	eReady,			/* The task being queried is in a read or pending ready list. */
	eBlocked,		/* The task being queried is in the Blocked state. */
	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
	eInvalid		/* Used as an 'invalid state' value. */
} eTaskState;
#endif
static void smb_cmd_taskinfo (SYS_CMD_DEVICE_NODE *pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	TaskStatus_t *pxTaskStatusArray;
	volatile UBaseType_t uxArraySize, x;
	unsigned long ulTotalRunTime, ulStatsAsPercentage;

	uxArraySize = uxTaskGetNumberOfTasks ();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "Total %d tasks are running now.." LINE_TERM, uxArraySize);

	/* Allocate a TaskStatus_t structure for each task.  An array could be allocated statically at compile time. */
	pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );

	if( pxTaskStatusArray != NULL ) {
		/* Generate raw status information about each task. */
		uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize,	&ulTotalRunTime );
		for( x = 0; x < uxArraySize; x++ ) {
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "The %dth : %s", x+1, pxTaskStatusArray[ x ].pcTaskName);
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "xTaskNumber = %d", pxTaskStatusArray[ x ].xTaskNumber);
			switch (pxTaskStatusArray[ x ].eCurrentState) {
			case eRunning : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eRunning", pxTaskStatusArray[ x ].pcTaskName); break;
			case eReady : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eReady", pxTaskStatusArray[ x ].pcTaskName); break;
			case eBlocked : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eBlocked", pxTaskStatusArray[ x ].pcTaskName); break;
			case eSuspended : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eSuspended", pxTaskStatusArray[ x ].pcTaskName); break;
			case eDeleted : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eDeleted", pxTaskStatusArray[ x ].pcTaskName); break;
			case eInvalid : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eInvalid", pxTaskStatusArray[ x ].pcTaskName); break;
			default : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s' eCurrentState is UNKNOWN !!", pxTaskStatusArray[ x ].pcTaskName); break;
			}
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "uxCurrentPriority = %d", pxTaskStatusArray[ x ].uxCurrentPriority);
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "uxBasePriority = %d", pxTaskStatusArray[ x ].uxBasePriority);
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "ulRunTimeCounter = %d", pxTaskStatusArray[ x ].ulRunTimeCounter);
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "pxStackBase = %#06"PRIx16, pxTaskStatusArray[ x ].usStackHighWaterMark);
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "usStackHighWaterMark = %d", pxTaskStatusArray[ x ].usStackHighWaterMark);
			(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
			//			osDelay(1);	// display 하다가 잘리는 현상 방지용. Queue buffer 를 8K 로 만들었으니 이제 필요없다.
		}

		// 아래는 running time 만 표시하는 루틴..
		/* For percentage calculations. */
		ulTotalRunTime /= 100UL;

		/* Avoid divide by zero errors. */
		if( ulTotalRunTime > 0 ) {
			/* For each populated position in the pxTaskStatusArray array,
	         format the raw data as human readable ASCII data. */
			for( x = 0; x < uxArraySize; x++ ) {
				/* What percentage of the total run time has the task used?
	            This will always be rounded down to the nearest integer.
	            ulTotalRunTimeDiv100 has already been divided by 100. */
				ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;

				if( ulStatsAsPercentage > 0UL )	{
					(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "%stt%lutt%lu%%rn",	\
							pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter,	ulStatsAsPercentage );
				}
				else {
					/* If the percentage is zero here then the task has
	               consumed less than 1% of the total run time. */
					(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "%stt%lutt<1%%rn", \
							pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter);
				}
			}
		}
		else {
			(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "Actual running time is < 1");
			(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
		}

		/* The array is no longer needed, free the memory it consumes. */
		vPortFree( pxTaskStatusArray );
	}
	else {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "pvPortMalloc () return NULL");
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
	}

	return;
}

static void smb_cmd_set_exti (SYS_CMD_DEVICE_NODE *pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint32_t exti_no;
	EXTI_HandleTypeDef exti_handle;

	if (argc != 2) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage : setexti exti_no (0 ~ 15)"LINE_TERM);
		return;
	}

	exti_no = strtoul (argv[1], NULL, 0);

	if (exti_no > 15) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage : setexti exti_no (0 ~ 15)"LINE_TERM);
		return;
	}

#if 0
#define EXTI_LINE_0                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x00u)
#define EXTI_LINE_1                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x01u)
#define EXTI_LINE_2                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x02u)
#define EXTI_LINE_3                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x03u)
#define EXTI_LINE_4                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x04u)
#define EXTI_LINE_5                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x05u)
#define EXTI_LINE_6                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x06u)
#define EXTI_LINE_7                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x07u)
#define EXTI_LINE_8                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x08u)
#define EXTI_LINE_9                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x09u)
#define EXTI_LINE_10                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Au)
#define EXTI_LINE_11                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Bu)
#define EXTI_LINE_12                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Cu)
#define EXTI_LINE_13                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Du)
#define EXTI_LINE_14                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Eu)
#define EXTI_LINE_15                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Fu)
#endif

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "Let EXTI_LINE_%d happen"LINE_TERM, exti_no);

	switch (exti_no) {
	case 0 : exti_handle.Line = EXTI_LINE_0; break;
	case 1 : exti_handle.Line = EXTI_LINE_1; break;
	case 2 : exti_handle.Line = EXTI_LINE_2; break;
	case 3 : exti_handle.Line = EXTI_LINE_3; break;
	case 4 : exti_handle.Line = EXTI_LINE_4; break;
	case 5 : exti_handle.Line = EXTI_LINE_5; break;
	case 6 : exti_handle.Line = EXTI_LINE_6; break;
	case 7 : exti_handle.Line = EXTI_LINE_7; break;
	case 8 : exti_handle.Line = EXTI_LINE_8; break;
	case 9 : exti_handle.Line = EXTI_LINE_9; break;
	case 10 : exti_handle.Line = EXTI_LINE_10; break;
	case 11 : exti_handle.Line = EXTI_LINE_11; break;
	case 12 : exti_handle.Line = EXTI_LINE_12; break;
	case 13 : exti_handle.Line = EXTI_LINE_13; break;
	case 14 : exti_handle.Line = EXTI_LINE_14; break;
	case 15 : exti_handle.Line = EXTI_LINE_15; break;
	default : assert (0 == 1); return; break;
	}

	HAL_EXTI_GenerateSWI(&exti_handle);
}

static void smb_cmd_scw (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) {
		goto USAGE;
	}

	do_scw_info_display = !do_scw_info_display;

	if (do_scw_info_display == true) {
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CLR);
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_HOME); osDelay(1);
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_HIDE); osDelay(1);
	}
	else {
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_SHOW);
	}
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "scw"LINE_TERM);
	return;

	return;
}

static uint8_t aShowTime[16] = "hh:ms:ss";
static uint8_t aShowDate[16] = "dd-mm-yyyy";

static void smb_cmd_show (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) goto USAGE;

	if (!strcmp(argv[1], "timer")) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, " osTimerList"LINE_TERM);
		for (uint32_t i = 0 ; i < OS_TIMER_INDEX_END ; i++) {
			if (osTimerList[i].osTimerId == NULL) continue;
			(*pCmdIO->pCmdApi->print)(cmdIoParam, " %2d : %s \t%4d ms \t%s"LINE_TERM,			\
					i, (osTimerList[i].osTimerType == osTimerOnce)?"osTimerOnce":"osTimerPeriodic", osTimerList[i].timeout_tick, osTimerList[i].timer_description);
		}
	}

	if (!strcmp(argv[1], "intr")) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, " IntrObjList"LINE_TERM);
		for (uint32_t i = SCW_RTU_INTR_INDEX_BEGIN ; i < SCW_RTU_INTR_INDEX_END ; i++) {
			if (strlen(IntrObjEntryList[i].IntrName) < 15) {
				(*pCmdIO->pCmdApi->print)(cmdIoParam, " %10d \t%s \t\t%s"LINE_TERM,			\
						IntrObjEntryList[i].IntrCount, IntrObjEntryList[i].IntrName, IntrObjEntryList[i].IntrDesc);
			}
			else {
				(*pCmdIO->pCmdApi->print)(cmdIoParam, " %10d \t%s \t%s"LINE_TERM,			\
						IntrObjEntryList[i].IntrCount, IntrObjEntryList[i].IntrName, IntrObjEntryList[i].IntrDesc);
			}
		}
	}
	if (!strcmp(argv[1], "system")) {
		uint32_t CPUID;
		uint32_t implementer, variant, constant, partno, version;
		uint32_t uid0, uid1, uid2;
		osVersion_t osv;
		osStatus_t status;
		char infobuf[100];

		// CPU ID
		CPUID = READ_REG(SCB->CPUID);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "CPUID=%#010"PRIx32 LINE_TERM, CPUID);

		implementer = LL_CPUID_GetImplementer();
		variant = LL_CPUID_GetVariant();
		constant = LL_CPUID_GetConstant();
		partno = LL_CPUID_GetParNo();
		version = LL_CPUID_GetRevision();


#if 0
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "implementer = %ld"LINE_TERM, implementer);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "variant = %ld"LINE_TERM, variant);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "constant = %ld"LINE_TERM, constant);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "partno = %ld"LINE_TERM, partno);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "version = %ld"LINE_TERM, version);
#endif

		assert (implementer == 0x41);
		assert (variant == 1);
		assert (constant == 0x0f);
		assert (partno == 0xC23);
		assert (version == 0x1);

		if (implementer == 0x41) (*pCmdIO->pCmdApi->msg)(cmdIoParam, "implementer = Arm"LINE_TERM);
		if (partno == 0xC23) (*pCmdIO->pCmdApi->msg)(cmdIoParam, "partno = Cortex-M3"LINE_TERM);


		// UID. Reference manual 의 Device electronic signature 참조할 것.
		uid0 = LL_GetUID_Word0();
		uid1 = LL_GetUID_Word1();
		uid2 = LL_GetUID_Word2();
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "uid0=%#010"PRIx32 LINE_TERM, uid0);	// X and Y coordinates on the wafer
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "uid1=%#010"PRIx32 LINE_TERM, uid1);	// LOT_NUM[23:0], WAFER_NUM[7:0]
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "uid2=%#010"PRIx32 LINE_TERM, uid2);	// Lot number (ASCII encoded)

		// OS
		status = osKernelGetInfo(&osv, infobuf, sizeof(infobuf));
		assert (status == osOK);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "Kernel Information: %s"LINE_TERM, infobuf);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "Kernel Version    : %d"LINE_TERM, osv.kernel);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "Kernel API Version: %d"LINE_TERM, osv.api);
	}
	if (!strcmp(argv[1], "time")) {
		/* Display date Format : mm-dd-yy */
		sprintf((char *)aShowDate, "%4d/%02d/%02d", 2000 + scw_infoObj.currentDate.Year, scw_infoObj.currentDate.Month, scw_infoObj.currentDate.Date);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s", aShowDate);
		switch (scw_infoObj.currentDate.WeekDay) {
		case RTC_WEEKDAY_MONDAY : 		sprintf((char *)aShowDate, "%s", "(Mon)"); break;
		case RTC_WEEKDAY_TUESDAY : 		sprintf((char *)aShowDate, "%s", "(Tue)"); break;
		case RTC_WEEKDAY_WEDNESDAY : 	sprintf((char *)aShowDate, "%s", "(Wed)"); break;
		case RTC_WEEKDAY_THURSDAY : 	sprintf((char *)aShowDate, "%s", "(Thu)"); break;
		case RTC_WEEKDAY_FRIDAY : 		sprintf((char *)aShowDate, "%s", "(Fri)"); break;
		case RTC_WEEKDAY_SATURDAY : 	sprintf((char *)aShowDate, "%s", "(Sat)"); break;
		case RTC_WEEKDAY_SUNDAY : 		sprintf((char *)aShowDate, "%s", "(Sun)"); break;
		default : 						sprintf((char *)aShowDate, "%s", "(NULL Day)"); break;
		}
		(*pCmdIO->pCmdApi->print)(cmdIoParam, " %s", aShowDate);
		sprintf((char *)aShowTime, " %02d:%02d:%02d %s", scw_infoObj.currentTime.Hours, scw_infoObj.currentTime.Minutes, scw_infoObj.currentTime.Seconds, (scw_infoObj.currentTime.Hours<12)?"am":"pm");
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "%s"LINE_TERM LINE_TERM , aShowTime);
	}
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, " show timer/intr/system/time"LINE_TERM);
	return;
}


static void smb_cmd_showuptime (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t day, hour, min, sec;
	uint64_t tmp;

	tmp = uptime_counter;

	day = tmp /DAY_TO_SEC;
	tmp = tmp - (day*DAY_TO_SEC);

	hour = tmp/HOUR_TO_SEC;
	tmp = tmp - (hour*HOUR_TO_SEC);

	min = tmp/MIN_TO_SEC;
	tmp = tmp - (min*MIN_TO_SEC);

	sec = tmp;

	(*pCmdIO->pCmdApi->print)(cmdIoParam, " Uptime = %d days, %d hours, %d mins, %d sec"LINE_TERM, day, hour, min, sec);

	return;
}

static const SYS_CMD_DESCRIPTOR    System_CommandTbl []=
{
		{"clear",       	smb_cmd_clearScreen,		"\t\t- clear screen"},
		{"c",       		smb_cmd_clearScreen,		"\t\t\t- clear screen"},

		{"taskinfo",		smb_cmd_taskinfo,			"\t\t- taskinfo"},
		{"setexti",    		smb_cmd_set_exti,       	"\t\t- setexti"},

		{"scw",     		smb_cmd_scw,				"\t\t- scw"},
		{"show",     		smb_cmd_show,      			"\t\t- show timer/intr/system/time"},
		{"uptime",     		smb_cmd_showuptime,      	"\t\t- uptime"},
		{"runtime",     	smb_cmd_showuptime,      	"\t\t- runtime"},

};

bool cmd_system_add ()
{
	assert (SYS_CMD_ADDGRP(System_CommandTbl, sizeof(System_CommandTbl)/sizeof(*System_CommandTbl), "system", ": system command group") == true);
	return true;
}

