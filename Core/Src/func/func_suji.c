/**
 ******************************************************************************
 * File Name          : func_suji.c
 * Description        : This file is generated by 위대한 송 인재 on Aug 13, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

extern suji_msg_func			suji_msg_handler_tbl[];
extern uint8_t 					SujiTxBuff[];

//
//
//static bool send_to_pc (uint8_t *buf, uint16_t size)
//{
//
//	HAL_UART_Transmit_DMA(&huart4, buf, size);
//	return true;
//}

static void send_rtu_version(suji_msg_body_t *pbody)
{
	uint8_t len = sizeof(FW_VERSION) + 2;
	memset (&SujiTxBuff[0], 0, SUJI_TX_BUFF_SIZE);
	SujiTxBuff[0] = STX;
	SujiTxBuff[1] = STX;
	SujiTxBuff[2] = 0;
	SujiTxBuff[3] = 0;
	SujiTxBuff[4] = 0;
	SujiTxBuff[5] = len;
	SujiTxBuff[6] = OPCODE_RTU_VERSION;
	SujiTxBuff[7] = 0x01;
	memcpy(&SujiTxBuff[8], FW_VERSION, sizeof(FW_VERSION));
	SujiTxBuff[len+6] = ETX;

	HAL_UART_Transmit_DMA(&huart4, &SujiTxBuff[0], len + 6 + 1);		// sizeof() 로 string 의 길이를 잴 때 마지막 NULL 문자 포함한 길이 return 하기 때문에 1 을 추가한다.
}

static void send_rtu_temperature(suji_msg_body_t *pbody, float temperature)
{
//	printf("%s() Got OPCODE_TEMPERATURE"LINE_TERM, __FUNCTION__);

	memset (&SujiTxBuff[0], 0, SUJI_TX_BUFF_SIZE);
	SujiTxBuff[0] = STX;
	SujiTxBuff[1] = STX;
	SujiTxBuff[2] = 0;
	SujiTxBuff[3] = 0;
	SujiTxBuff[4] = 0;
	SujiTxBuff[5] = 6;
	SujiTxBuff[6] = OPCODE_TEMPERATURE;
	SujiTxBuff[7] = 0x01;
	memcpy(&SujiTxBuff[8], &temperature, sizeof(float));
	SujiTxBuff[12] = ETX;

	HAL_UART_Transmit_DMA(&huart4, &SujiTxBuff[0], 13);
}

static void send_rtu_humidity(suji_msg_body_t *pbody, float humidity)
{
//	printf("%s() Got OPCODE_HUMIDITY"LINE_TERM, __FUNCTION__);

	memset (&SujiTxBuff[0], 0, SUJI_TX_BUFF_SIZE);
	SujiTxBuff[0] = STX;
	SujiTxBuff[1] = STX;
	SujiTxBuff[2] = 0;
	SujiTxBuff[3] = 0;
	SujiTxBuff[4] = 0;
	SujiTxBuff[5] = 6;
	SujiTxBuff[6] = OPCODE_HUMIDITY;
	SujiTxBuff[7] = 0x01;
	memcpy(&SujiTxBuff[8], &humidity, sizeof(float));
	SujiTxBuff[12] = ETX;

	HAL_UART_Transmit_DMA(&huart4, &SujiTxBuff[0], 13);
}

static void send_rtu_watchdog_use(suji_msg_body_t *pbody)
{
//	printf("%s() Got OPCODE_WATCHDOG_USE"LINE_TERM, __FUNCTION__);
	memset (&SujiTxBuff[0], 0, SUJI_TX_BUFF_SIZE);
	memcpy (&SujiTxBuff[0], pbody, SUJI_TX_BUFF_SIZE);
	HAL_UART_Transmit_DMA(&huart4, &SujiTxBuff[0], 10);
}

static void send_rtu_watchdog_set(suji_msg_body_t *pbody)
{
//	printf("%s() Got OPCODE_WATCHDOG_SET"LINE_TERM, __FUNCTION__);
	memset (&SujiTxBuff[0], 0, SUJI_TX_BUFF_SIZE);
	memcpy (&SujiTxBuff[0], pbody, SUJI_TX_BUFF_SIZE);
	HAL_UART_Transmit_DMA(&huart4, &SujiTxBuff[0], 10);
}

static void send_rtu_fan_temp_set(suji_msg_body_t *pbody)
{
//	printf("%s() Got OPCODE_FAN_TEMP_SET"LINE_TERM, __FUNCTION__);
	memset (&SujiTxBuff[0], 0, SUJI_TX_BUFF_SIZE);
	memcpy (&SujiTxBuff[0], pbody, SUJI_TX_BUFF_SIZE);
	HAL_UART_Transmit_DMA(&huart4, &SujiTxBuff[0], 10);
}

static void send_rtu_heater_temp_set(suji_msg_body_t *pbody)
{
//	printf("%s() Got OPCODE_HEATER_TEMP_SET"LINE_TERM, __FUNCTION__);
	memset (&SujiTxBuff[0], 0, SUJI_TX_BUFF_SIZE);
	memcpy (&SujiTxBuff[0], pbody, SUJI_TX_BUFF_SIZE);
	HAL_UART_Transmit_DMA(&huart4, &SujiTxBuff[0], 10);
}

static void send_rtu_adv_panel_lamp_set(suji_msg_body_t *pbody)
{
//	printf("%s() Got OPCODE_ADV_PANEL_LAMP_SET"LINE_TERM, __FUNCTION__);
	memset (&SujiTxBuff[0], 0, SUJI_TX_BUFF_SIZE);
	memcpy (&SujiTxBuff[0], pbody, SUJI_TX_BUFF_SIZE);
	HAL_UART_Transmit_DMA(&huart4, &SujiTxBuff[0], 10);
}

static void send_rtu_xavier_control(suji_msg_body_t *pbody)
{
//	printf("%s() Got OPCODE_XAVIER_CONTROL"LINE_TERM, __FUNCTION__);
	memset (&SujiTxBuff[0], 0, SUJI_TX_BUFF_SIZE);
	memcpy (&SujiTxBuff[0], pbody, SUJI_TX_BUFF_SIZE);
	HAL_UART_Transmit_DMA(&huart4, &SujiTxBuff[0], 10);
}

static void send_rtu_lamp_post_control(suji_msg_body_t *pbody)
{
//	printf("%s() Got OPCODE_LAMP_POST_CONTROL"LINE_TERM, __FUNCTION__);
	memset (&SujiTxBuff[0], 0, SUJI_TX_BUFF_SIZE);
	memcpy (&SujiTxBuff[0], pbody, SUJI_TX_BUFF_SIZE);
	HAL_UART_Transmit_DMA(&huart4, &SujiTxBuff[0], 10);
}

static void send_rtu_status_info(suji_msg_body_t *pbody)
{
	memset (&SujiTxBuff[0], 0, SUJI_TX_BUFF_SIZE);
	SujiTxBuff[0] = STX;
	SujiTxBuff[1] = STX;
	SujiTxBuff[2] = 0;
	SujiTxBuff[3] = 0;
	SujiTxBuff[4] = 0;
	SujiTxBuff[5] = 0x2D;
	SujiTxBuff[6] = OPCODE_STATUS_INFO;
	SujiTxBuff[7] = 0x01;

	SujiTxBuff[8] = 0x01;		// watchdog 사용 상태
	SujiTxBuff[9] = 0x01;		// watchdog 값
	SujiTxBuff[10] = 0x01;		// door_1
	SujiTxBuff[11] = 0x01;		// door_2
	SujiTxBuff[12] = 0x01;		// fan 동작 상태
	SujiTxBuff[13] = 0x46;		// fan 온도 max
	SujiTxBuff[14] = 0x0;		// fan 온도 min
	SujiTxBuff[15] = 0x01;		// heater 동작 상태
	SujiTxBuff[16] = 0x46;		// heater 온도 max
	SujiTxBuff[17] = 0x00;		// heater 온도 min
	SujiTxBuff[18] = 0x20;		// 현재 온도 (float 4Byte)
	SujiTxBuff[22] = 0x40;		// 현재 습도 (float 4Byte)

	SujiTxBuff[51] = ETX;
	HAL_UART_Transmit_DMA(&huart4, &SujiTxBuff[0], 52);
}

static bool suji_msg_handler_default(suji_msg_t *pmsg)
{
	char suji_msg[100];

	switch (pmsg->head.type) {
	case SUJI_MSG_BASE : strcpy (suji_msg, "SUJI_MSG_BASE"); break;
	case SUJI_MSG_COMMAND : strcpy (suji_msg, "SUJI_MSG_COMMAND"); break;
	default : strcpy (suji_msg, "UNKNOWN type"); break;
	}

	printf("%s() : suji_msg_type = %s"LINE_TERM, __FUNCTION__, suji_msg);

	return true;
}

static bool suji_command_integrity_check(suji_msg_body_t *pbody)
{
	if (pbody->Byte[0] != STX) return false;
	if (pbody->Byte[1] != STX) return false;
	else return true;
}

void doSystemReset();
static bool suji_msg_handler_command(suji_msg_t *pmsg)
{
	if (suji_command_integrity_check(&pmsg->body) != true) {
		printf("%s() Incorrect command"LINE_TERM, __FUNCTION__);
		HexDump(0, &pmsg->body.Byte[0], pmsg->head.len);
	}

	suji_command_opcode_type_t suji_command_opcode = pmsg->body.Byte[6];
	switch (suji_command_opcode) {
	case OPCODE_POWER_RESET :
		printf(CUI_ESC_CLR);
		printf(CUI_ESC_CUR_HOME);
		printf(LINE_TERM"====== MANUAL SYSTEM RESET ======="LINE_TERM);
		HAL_Delay(4);
		doSystemReset();
		break;

	case OPCODE_RTU_VERSION :
		send_rtu_version((suji_msg_body_t *)&pmsg->body);
		break;

	case OPCODE_TEMPERATURE :
		send_rtu_temperature((suji_msg_body_t *)&pmsg->body, 0.0);
		break;

	case OPCODE_HUMIDITY :
		send_rtu_humidity((suji_msg_body_t *)&pmsg->body, 0.0);
		break;

	case OPCODE_WATCHDOG_USE :
		send_rtu_watchdog_use((suji_msg_body_t *)&pmsg->body);
		break;

	case OPCODE_WATCHDOG_SET :
		send_rtu_watchdog_set((suji_msg_body_t *)&pmsg->body);
		break;

	case OPCODE_FAN_TEMP_SET :
		send_rtu_fan_temp_set((suji_msg_body_t *)&pmsg->body);
		break;

	case OPCODE_HEATER_TEMP_SET :
		send_rtu_heater_temp_set((suji_msg_body_t *)&pmsg->body);
		break;

	case OPCODE_ADV_PANEL_LAMP_SET :
		send_rtu_adv_panel_lamp_set((suji_msg_body_t *)&pmsg->body);
		break;

	case OPCODE_XAVIER_CONTROL :
		send_rtu_xavier_control((suji_msg_body_t *)&pmsg->body);
		break;

	case OPCODE_LAMP_POST_CONTROL :
		send_rtu_lamp_post_control((suji_msg_body_t *)&pmsg->body);
		break;

	case OPCODE_STATUS_INFO :
		send_rtu_status_info((suji_msg_body_t *)&pmsg->body);
		break;

	default :
		printf("%s() Got UNDEFINED OP_CODE"LINE_TERM, __FUNCTION__);
		break;
	}
	return true;
}

bool suji_msg_handler_tbl_init(void)
{
	for (uint32_t i = 0 ; i < SUJI_MSG_END ; i++) {
		suji_msg_handler_tbl[i] = suji_msg_handler_default;
	}

	suji_msg_handler_tbl[SUJI_MSG_COMMAND] = suji_msg_handler_command;

	return true;
}
