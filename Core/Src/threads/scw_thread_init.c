/**
 ******************************************************************************
  * File Name          : scw_thread_init.c
  * Description        : This file is generated by 위대한 송 인재 on Aug 8, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

bool osTimerList_init(osTimerEntry_t osTimerList[]);
bool IntrList_init(IntrObjEntry_t IntrObjEntryList[]);


/**************************************************************************************************
 * function : HW 상태에 따라 초기 Status 정보를 구성
 * arg : SatusObj pinter
 * return : bool
 **************************************************************************************************/
static bool scw_infoObj_init(scw_infoObj_t *psio)
{
	strcpy (psio->fw_version, FW_VERSION);

	psio->CPUID = READ_REG(SCB->CPUID);
	psio->implementer = LL_CPUID_GetImplementer();
	psio->variant = LL_CPUID_GetVariant();
	psio->constant = LL_CPUID_GetConstant();
	psio->partno = LL_CPUID_GetParNo();
	psio->version = LL_CPUID_GetRevision();

	psio->uid0 = LL_GetUID_Word0();
	psio->uid1 = LL_GetUID_Word1();
	psio->uid2 = LL_GetUID_Word2();
	psio->counter_admin = 0;

	assert (HAL_RTC_GetTime(&hrtc, &psio->currentTime, RTC_FORMAT_BIN) == HAL_OK);
	assert (HAL_RTC_GetDate(&hrtc, &psio->currentDate, RTC_FORMAT_BIN) == HAL_OK);
	assert (HAL_RTC_GetTime(&hrtc, &psio->launchTime, RTC_FORMAT_BIN) == HAL_OK);
	assert (HAL_RTC_GetDate(&hrtc, &psio->launchDate, RTC_FORMAT_BIN) == HAL_OK);

	// door switch  가 움직일 때 rising/falling edge 가 glitch 처럼 많이 발생하기 때문에 아래와 같이 timer 로 처리하기로 함.
	psio->scw_door.door_1_status = get_door_1_status();
	psio->scw_door.door_2_status = get_door_2_status();

	return true;
}

static bool uptime_counter_begin()
{
	assert (osTimerList[OS_TIMER_INDEX_UPTIME_COUNT].osTimerId != NULL);
	assert (osTimerStart(osTimerList[OS_TIMER_INDEX_UPTIME_COUNT].osTimerId, osTimerList[OS_TIMER_INDEX_UPTIME_COUNT].timeout_tick) == osOK);
	return true;
}

void scw_thread_init (void *arg)
{
	DbgTraceInit();

	assert (scw_rtc_init() == true);
	assert (IntrList_init(&IntrObjEntryList[SCW_RTU_INTR_INDEX_BEGIN]) == true);
	assert (osTimerList_init(&osTimerList[OS_TIMER_INDEX_BEGIN]) == true);
	assert (scw_infoObj_init(&scw_infoObj) == true);
	assert (SHT2x_Init(&hi2c1) == true);
	assert (adc_initial_calibration() == true);

	do_scw_info_display = false;
	scw_banner = BANNER_ECELL;
	uptime_counter = 0;
	assert (uptime_counter_begin() == true);

	osThreadExit();
}
