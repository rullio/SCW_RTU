/**
 ******************************************************************************
  * File Name          : sc_thread_cli.c
  * Description        : This file is generated by 위대한 송 인재 on Jun 11, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

#define	CONSOLE_SCAN_TIMEOUT	TIMEOUT_10_MSEC

bool scw_cmd_system_add ();
bool scw_cmd_misc_add ();

void RunCmdTask(SYS_CMD_IO_DCPT* pCmdIO);
bool uartObj_Init( void );
bool SYS_CMD_Initialize(const SYS_MODULE_INIT * const init );
SYS_MODULE_OBJ SYS_CONSOLE_Initialize (const SYS_MODULE_INDEX index, const SYS_MODULE_INIT* const init);
SYS_CMD_DEVICE_NODE* SYS_CMDIO_ADD(const SYS_CMD_API* opApi, const void* cmdIoParam, int unused);
bool RxPushByte (uint8_t rdByte);
void Greeting(void);


extern osThreadId_t Thread_CLI_Handler;
extern const SYS_CMD_INIT sysCmdInit;
extern const SYS_CONSOLE_INIT sysConsole0Init;
extern const SYS_CMD_API sysConsoleApi;
extern SYS_CMD_INIT _cmdInitData;
extern SYS_CMD_DEVICE_LIST	cmdIODevList;

static	uint8_t				ConsoleChar;
static	osTimerId_t			console_scan_timerId;

void RxCpltCallback(void)
{
	RxPushByte (ConsoleChar);
	HW_UART_Receive_IT(CFG_DEBUG_TRACE_UART, &ConsoleChar, 1U, RxCpltCallback);
}

static bool console_init ()
{
	assert (uartObj_Init() == true);
	assert (SYS_CMD_Initialize((SYS_MODULE_INIT*)&sysCmdInit) == true);
	assert (SYS_CONSOLE_Initialize(SYS_CONSOLE_INDEX_0, (SYS_MODULE_INIT *)&sysConsole0Init) != SYS_MODULE_OBJ_INVALID);
	assert (SYS_CMDIO_ADD(&sysConsoleApi, &_cmdInitData.consoleCmdIOParam, _cmdInitData.consoleCmdIOParam) != 0);

	return true;
}


static bool scw_cmds_add ()
{
	return true;
}

static void console_scan_timeout_cb (void *arg)
{
	osThreadFlagsSet(Thread_CLI_Handler, EF_CONSOLE_SCAN);
}

static bool console_scan_timer_begin ()
{
	console_scan_timerId = osTimerNew(console_scan_timeout_cb, osTimerOnce, NULL, NULL);
	assert (console_scan_timerId != NULL);
	assert (osTimerStart(console_scan_timerId, CONSOLE_SCAN_TIMEOUT) == osOK);
	return true;
}

void scw_thread_cli (void *arg)
{
	uint32_t cli_event_flag = 0;
	uint32_t cli_wait_flag = 		\
			EF_CONSOLE_SCAN			\
			;

	assert (console_init () == true);
	assert (scw_cmds_add () == true);
	HW_UART_Receive_IT(CFG_DEBUG_TRACE_UART, &ConsoleChar, 1U, RxCpltCallback);
	HAL_NVIC_EnableIRQ(USART1_IRQn);
	assert (console_scan_timer_begin () == true);
	Greeting();

	while (1) {
		cli_event_flag = osThreadFlagsWait(cli_wait_flag, osFlagsWaitAny, osWaitForever);
		assert (!(cli_event_flag & THREAD_FLAG_MASK_ERROR));

		if (cli_event_flag & EF_CONSOLE_SCAN) {
			RunCmdTask(cmdIODevList.head);
			assert (osTimerStart(console_scan_timerId, CONSOLE_SCAN_TIMEOUT) == osOK);
		}
	}
}
